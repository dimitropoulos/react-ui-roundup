import { promises as fs } from 'fs';
import {
  append,
  chain,
  filter,
  includes,
  indexBy,
  intersperse,
  map,
  pipe,
  pluck,
  prop,
  reject,
  sortBy,
  update,
  values,
  whereEq,
} from 'ramda';
import { compact, concatAll } from 'ramda-adjunct';

import { componentInfo } from '../components';
import { tableOfContentsIntro } from '../copy';
import { Component, Framework, RepoInfo } from '../entities';
import { frameworkInfo, frameworks } from '../frameworks';
import { createScrollId, getRepoInfo, issueURL, noValue, removeProtocol, toStablePairs } from '../utils';
import {
  ContentGroup,
  criteria,
  h1,
  h2,
  inlineCode,
  lines,
  link,
  paragraph,
  quote,
  table,
  tableOfContents,
  website,
  websiteHref,
} from './utils';

interface RepoInfoByHtmlUrl {
  [htmlUrl: string]: RepoInfo;
}

const { writeFile } = fs;

const pleaseFileIssue = link({
  href: issueURL,
  text: 'Please file an issue',
});

const tableOfContentsMarkdown = [
  h1('React UI Roundup'),
  paragraph(tableOfContentsIntro),
  tableOfContents([
    { href: '#About', text: 'About' },
    { href: '#Framework-Statistics', text: 'Framework Statistics' },
    { href: '#Framework-Features', text: 'Framework Features' },
    { href: '#Components', text: 'Components' },
    map(({ cannonicalName }) => ({ href: `#${createScrollId(cannonicalName)}`, text: cannonicalName }), componentInfo),
  ]),
];

const aboutMarkdown = [
  h1('About'),
  paragraph(`I decided to make this project ${link({ href: 'https://github.com/mui-org/material-ui/issues/18094', text: 'while contributing an Alert component to material-ui' })}. While thinking about that component, it was HUGELY helpful to review other implementations from everything from feature set, DOM structure, CSS usage, theming integration, prop naming, and more. I wanted something where I could stand back at a distance and look at many high-quality implementations of a similar component while I researched - so I made this project.`),
  paragraph(`An even more better version of this exact document is available at ${website}.  It has special "Open All" buttons that allow you to open every link in a table with one click!  Also, the Framework Statistics section on the website is always up to date since it pulls the data in realtime when you load the page.`),
];

const howToMakeAChange = [
  h1('How to Make a Change'),
  paragraph(`The README.md and website are both autogenerated from the same source input files.  For convenience, there is exactly one file for each project that has all the information for that project, located in the ${link({ href: 'https://github.com/dimitropoulos/react-ui-roundup/tree/master/frameworks', text: inlineCode('frameworks directory') })}.  To update any given data point, simply make a change to one of those files and run ${inlineCode('yarn generate')}.`),
];

const frameworksSectionMarkdown = (repoInfoByHtmlUrl: RepoInfoByHtmlUrl) => [
  h2('Framework Statistics'),
  table({
    headers: [
      'Name',
      'Homepage',
      'Repository',
      'Stars',
      'Forks',
      'Issues',
      'License',
    ],
    rows: map(({ frameworkName, frameworkHomepage, repoURL }) => [
      frameworkName,
      link({ href: frameworkHomepage, text: removeProtocol(frameworkHomepage) }),
      link({ href: repoURL, text: removeProtocol(repoURL).replace(/github\.com\//, '') }),
      repoInfoByHtmlUrl[repoURL]?.stargazers_count?.toLocaleString() ?? noValue,
      repoInfoByHtmlUrl[repoURL]?.forks_count?.toLocaleString() ?? noValue,
      repoInfoByHtmlUrl[repoURL]?.open_issues_count?.toLocaleString() ?? noValue,
      repoInfoByHtmlUrl[repoURL]?.license?.name?.replace(/ License/, '') ?? noValue,
    ], frameworks),
  }),
  quote(`all of the above statistics were last updated ${new Date().toUTCString()}.  For real-time data, ${link({ href: websiteHref, text: 'see the website' })}.`),
];

const frameworkFeaturesSectionMarkdown = [
  h2('Framework Features'),
  criteria(map(({ name, criteria }) => [name, criteria], frameworkInfo)),
  table({
    headers: [
      'Name',
      ...pluck('name', frameworkInfo),
    ],
    rows: map(({ frameworkName, frameworkFeaturesById }) => [
      frameworkName,
      ...map(({ toMarkdown, featureId }) => (
        // @ts-expect-error there's no way to prove that the `featureId` we're indexing into returns a boolean at this level
        toMarkdown(frameworkFeaturesById[featureId])
      ), frameworkInfo),
    ], frameworks),
  }),
];

const frameworksMarkdown = (repoInfoByHtmlUrl: RepoInfoByHtmlUrl) => [
  h1('Frameworks'),
  frameworksSectionMarkdown(repoInfoByHtmlUrl),
  frameworkFeaturesSectionMarkdown,
];

type EnhancedComponent = Component & Pick<Framework, 'frameworkId' | 'frameworkName'>;

const componentsMarkdown = [
  h1('Components'),
  ...chain(({ componentId, cannonicalName, description, indefiniteArticle, optionsById }) => {
    const optionsArray = pipe(
      () => optionsById,
      values,
      sortBy(prop('name')),
    )();

    const headers = [
      'Framework',
      'Name',
      ...pluck('name', optionsArray),
    ];

    const enhancedComponents: EnhancedComponent[] = chain(({ components, frameworkId, frameworkName }) => (
      map(component => ({
        ...component,
        frameworkId,
        frameworkName,
      }), components)
    ), frameworks);

    const filteredComponents = filter(whereEq({ componentId }), enhancedComponents);
    const rows = map<EnhancedComponent, string[]>(({ componentName, frameworkName, componentURL, options }) => [
      frameworkName,
      link({ href: componentURL, text: componentName }),
      // @ts-expect-error types failing since `options`'s properties cannot be proved to match the `optionId`
      ...map(({ optionId, toMarkdown }) => toMarkdown(options[optionId]), optionsArray),
    ], filteredComponents);


    const filteredMissingFrameworks = filter(whereEq({ componentId }), enhancedComponents);
    const missingFrameworkIds = pluck('frameworkId', filteredMissingFrameworks);
    const missingFrameworks: ContentGroup = pipe(
      () => missingFrameworkIds,
      frameworkIds => reject(
        framework => includes(framework.frameworkId, frameworkIds),
        frameworks,
      ),
      map(({ frameworkName, repoURL }) => (
        link({ href: repoURL, text: frameworkName })
      )),
      intersperse(', '),
      elements => {
        switch (elements.length) {
          case 0:
            return [];

          case 1:
            return elements;

          case 3:
            return update(1, ' and ', elements);

          default:
            return update(elements.length - 2, ', and ', elements);
        }
      },
      elements => (elements.length > 0 ? append(
        ` appear${elements.length === 1 ? 's' : ''} to be missing ${indefiniteArticle} ${cannonicalName} component. ${pleaseFileIssue} if one now exists.\n`,
        elements,
      ) : []),
      concatAll,
      line => [typeof line === 'string' && line.length > 0 ? quote(line) : ''],
    )();

    return [
      h2(cannonicalName),
      paragraph(typeof description === 'string' ? description : description.markdown),
      criteria(map(([, value]) => (
        [value.name, value.criteria]
      ), toStablePairs(optionsById))),
      table({
        headers,
        rows,
      }),
      missingFrameworks,
    ];
  }, componentInfo),
];

const fetchAll = async () => {
  const repoInfo = await Promise.all(
    map(({ repoURL }) => getRepoInfo(repoURL), frameworks),
  );

  const readme = lines([
    tableOfContentsMarkdown,
    aboutMarkdown,
    frameworksMarkdown(indexBy(prop('html_url'), compact(repoInfo))),
    componentsMarkdown,
    howToMakeAChange,
  ]);

  try {
    await writeFile('README.md', readme);
  } catch (error: unknown) {
    if (typeof error === 'string') {
      throw new Error(error);
    }
  }
};

fetchAll()
  .then(() => {
    console.log('readme generated successfully');
  })
  .catch(error => {
    console.error(error);
  });
